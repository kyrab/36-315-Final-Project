---
title: "35-315 Final Project Report"
author: "Kyra Balenzano, Evan Feder, David Yuan"
date: "5/2/2020"
output: pdf_document
linestretch: 1.241
fontsize: 12pt
header-includes:
  - \setlength{\parindent}{2em}
  - \usepackage{setspace} \doublespacing
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r message = F, warning = F}
# Load the required libraries
library(tidyverse)
library(pander)
library(gridExtra)
library(wordcloud)
library(tm)
library(ggseas)
library(dendextend)
library(devtools)
#install_github("vqv/ggbiplot")
library(ggbiplot)
```

```{r message = F, warning = F}
spotify <- read.csv("spotify-2000.csv") # Load the data

# Easier column names
colnames(spotify)[1] <- "Index"
colnames(spotify)[6] <- "BPM"
colnames(spotify)[9] <- "Loudness"
colnames(spotify)[12] <- "Duration"

# Cleaning up the genres column
rock <- c("album rock", "alternative metal", "classic rock", "modern rock", 
          "alternative rock", "garage rock", "permanent wave", "modern folk rock",
          "irish rock", "art rock", "celtic rock", "dutch rock", "belgian rock",
          "british invasion", "finnish metal", "dutch metal", "soft rock", "dutch prog",
          "dance rock", "mellow gold", "glam metal", "australian rock", "australian psych",
          "rock-and-roll", "glam rock", "hard rock", "punk", "j-core", "australian
          alternative rock", "yacht rock", "celtic punk", "classic canadian rock",
          "cyberpunk", "classical rock", "christelijk", "canadian rock", "british
          alternative rock", "german alternative rock")
pop <- c("alternative pop rock", "pop", "classic uk pop", "dance pop", "dutch pop",
         "alternative dance", "german pop", "afropop", "disco", "danish pop rock",
         "britpop", "neo mellow", "boy band", "hip pop", "australian pop", "canadian pop",
         "bow pop", "acoustic pop", "candy pop", "operatic pop", "alternative pop",
         "eurodance", "art pop", "uk pop", "brill building pop", "belgian pop",
         "barbadian pop", "chamber pop", "indie pop", "electropop", "folk-pop",
         "metropopolis", "irish pop", "australian dance", "nederpop", "danish pop",
         "italian pop", "la pop", "baroque pop", "austropop", "ccm", "bubblegum pop",
         "europop", "new wave pop", "german pop rock", "levenslied", "classic 
         italian pop", "pop punk")
country <- c("dutch americana", "arkansas country", "british folk", "blues rock",
             "canadian folk", "contemporary country", "australian indie folk", 
             "indie anthem-folk", "australian americana", "classic country pop",
             "folk", "alternative country")
indie <- c("dutch indie", "alaska indie", "icelandic indie")
hip_hop <- c("alternative hip top", "detroit hip hop", "east coast hip hop", 
             "dutch hip hop", "atl hip hop", "g funk", "gangster rap")

findDecade = function(x) {
  ifelse(x >= 1950 && x <= 1969, "1950s-60s", 
    ifelse(x >= 1970 && x <= 1979, "1970s",
      ifelse(x >= 1980 && x <= 1989, "1980s",
        ifelse(x >= 1990 && x <= 1999, "1990s",
          ifelse(x >= 2000 && x <= 2009, "2000s", "2010s")))))
}

findRange = function(x) {
  ifelse(x >= 1950 && x <= 1989, "1950s-1980s", "1990s-2010s")
}

spotify$Decade = sapply(spotify$Year, FUN = findDecade)
spotify$Range = sapply(spotify$Year, FUN = findRange)

spotify = spotify %>%
  mutate(Genre = ifelse(Top.Genre %in% rock, "rock",
                 ifelse(Top.Genre %in% pop, "pop",
                 ifelse(Top.Genre %in% country, "country",
                 ifelse(Top.Genre %in% indie, "indie",
                 ifelse(Top.Genre %in% hip_hop, "hiphop", "other")))))) %>% 
  mutate(Genre = factor(Genre),
         Duration = as.integer(Duration),
         Decade = factor(Decade),
         Range = factor(Range))
```

# Introduction

The "Spotify: All Time Top 2000 Mega Dataset" is a dataset from [Kaggle](https://www.kaggle.com/iamsumat/spotify-top-2000s-mega-dataset) that contains various audio statistics and ratings of the top 1,994 songs on Spotify. For each song, it includes information such as the Title, Artist, Top Genre, Year of release, BPM (beats per minute), and Duration. The first three are nominal categorical variables, Year is an ordinal categorical variable, and the last two are quantitative variables. In addition, for each song, this dataset includes various quantitative ratings, such as those measuring its level of Energy, Danceability, Loudness, Liveness, Valence, Acousticness, Speechiness, and Popularity.

We added additional Genre, Decade, and Decade Range columns so that we could cluster songs into fewer groups, which in turn make visualizations more clear. The Genre column was created by manually sorting the 149 unique Top Genres into six main categories (Rock, Pop, Country, Hip Hop, Indie, and Other). *[ADDRESS BIAS?]* Meanwhile, the Decade and Decade Range columns were able to be assembled programmatically.

Using this dataset, we will answer three main questions in our report:

+ Which attributes are associated with which genres?

+ Which attributes do popular songs tend to have?

+ How have the attributes of songs that appear on the top 2000 list changed over time?

\newpage

# Analysis

## [Remove before handing in] Kyra's Graphs / Question 3: Time

Since we had so many quantitative variables, we first tried to condense them into a couple of dimensions and see if there were any changes over time. We performed this dimension reduction using principal component analysis (PCA), plotted the first two dimensions of this result, and then colored the datapoints by the Decade Range variable so that we could make some comparisons regarding time without clouding the graph with too many overlapping colors.  

```{r}
######### PCA PLOT #########

# Just include qualitative variables for PCA
spotify.subset = spotify %>% 
  select(-c(Index, Title, Artist, Top.Genre, Year, Genre, Decade, Range, mds1, mds2))

# From R Demo, Lecture 18:
spotify.center = apply(spotify.subset, MARGIN = 2, FUN = function(x) x - mean(x))
spotify.standard = apply(spotify.center, MARGIN = 2, FUN = function(x) x/sd(x))

spotify.pca = prcomp(spotify.standard, center = TRUE, scale. = TRUE)
rotation.pca = as.matrix(spotify.pca$rotation)

# Compute Gamma vectors, which is defined as X \times rotation:
prinComps = as.matrix(spotify.standard) %*% rotation.pca
dim(prinComps)
apply(prinComps, MARGIN = 2, FUN = sd)
```

```{r}
# First two dimensions of PCA
ggbiplot(spotify.pca, ellipse = TRUE, groups = spotify$Range, alpha = 0.5) +
  labs(color = "Decade Range",
       x = "Standardized PC1 (26.3% explained var.)",
       y = "Standardized PC2 (15.2% explained var.)")
```

We can see that Decade Range very vaguely clusters by the first two components, since more of the blue datapoints are on the top and more of the red red datapoints are on the bottom. One example of a conclusion that can be drawn from the graph is that as BPM increases, both PC1 decreases and PC2 increases, which further allows us to conclude that songs from the 1990s-2010s tend to have a greater number of beats per minute than songs from the 1950s-1980s. That being said, since the Normal distribution ellipses overlap quite a bit, there is not enough evidence to conclude that the two groups are significantly different with respect to their principal components.

```{r}
t.test(x = spotify.pca$x[spotify$Range == "1950s-1980s", "PC2"],
       y = spotify.pca$x[spotify$Range == "1990s-2010s", "PC2"])
```

```{r, results = 'hide'}
# Here is the proportion of variance accounted by each principal component:
varProps = summary(spotify.pca)$importance["Proportion of Variance",]
# Draw the line
plot(1:ncol(spotify.standard), varProps, type = "l",
     xlab = "Component Number", ylab = "Proportion of Variation")
# Add the points
points(1:ncol(spotify.standard), varProps, pch = 16)
```

Notes:
Lecture 18 R Demo -- arrow plot thing, making ellipses around the clusters.
PCA -- arrows.
Note that scree plot suggests use of third dimension but we did not use.
Use statistical analyses -- t tests in terms of x variable.

```{r}
######### MULTICOLORED DENSITY CURVE #########

#findRange2 = function(x) {
#  ifelse(x == "1950s-60s" || x == "1970s", "1950s-70s",
#    ifelse(x == "1980s" || x == "1990s", "1980s-90s", "2000s-10s"))
#}

#spotify$Range2 = sapply(spotify$Decade, FUN = findRange2)
```

```{r}
# Also good: Popularity, Valence w/ Range. Mediocre: Energy, Loudness.
# Bad: Liveness, Acousticness, Speechiness, Danceability

ggplot(data = spotify, aes(x = Duration, color = Decade)) +
  geom_density(size = 1.25) +
  labs(color = "Range")
```

Interpretation: song duration has changed throughout the decades. All are right skewed but 1950s-1960s seemed to have the smallest duration mode, followed by 1970s, 2010s, 2000s, 1980s, and then 1990s. Seemed to have cycled around.

```{r}
######### TIME SERIES #########
average = spotify %>% 
  group_by(Year) %>% 
  dplyr::summarize(avg = median(Danceability))
```

```{r, warning = FALSE, message = FALSE}
# Also good: Loudness, Energy, Popularity

ggplot(data = average, aes(x = Year, y = avg)) +
  geom_line(color = "red") +
  stat_rollapplyr(width = 4, align = "right", size = 2, alpha = .4) + 
  labs(title = "Median Danceability vs. Year",
       subtitle = "Width = 4",
       x = "Year", y = "Median Danceability")
```

```{r, warning = FALSE, message = FALSE}
######### ARTIST NAME WORDCLOUD #########
# Big name ==> more popular, can modify to replace artists with song names too

# Redefine as Corpus
artists = Corpus(VectorSource(spotify$Artist))

# Remove punctuations
artists = tm_map(artists, removePunctuation)

dtm.artists = DocumentTermMatrix(artists, control = list(stopwords = TRUE))

artists.words = dtm.artists$dimnames$Terms
artists.freqs = colSums(as.matrix(dtm.artists))

wordcloud(words = artists.words, freq = artists.freqs, 
          random.order = FALSE, max.words = 150, colors = brewer.pal(8, "Paired"))
```

Note limitations!!

# Conclusions

Future work: adding and interpreting a third dimension to the PCA plot. Adding the third dimension has been learned, but not yet interpreting. Explore every quantitative variable in time analysis individually.

